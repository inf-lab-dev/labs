from flask import Blueprint, Response, current_app, send_file, abort
import json
import hashlib
import os

# Create a blueprint to hook into Flask
static = Blueprint('static', __name__)


def _inject(server_start, stock):
    """
    Creates the payload that should be injected into all HTML pages.
    This payload contains the data for the frontend (and the server's state) as well as loading the provided
    frontend and thus the file watcher.

    :param server_start: the ISO-Timestamp when the server started, is needed to automatically clear stored state
    :param stock: the currently available stock, right from the `stock` module

    """

    # transmit this data as json
    initial_stock = json.dumps(stock)

    # hash the json, so we easily notice changes
    stock_sha = hashlib.sha256(initial_stock.encode('utf8')).hexdigest()

    return f"""
<script>
    // Dont be confused! This script is nowhere to be found within your HTML page!
    // It's actually injected dynamically using the python server.
    //  You can safely assume that it does not break anything!

    window.serverState = '{stock_sha}-{server_start}';
    window.initialStock = {initial_stock};
</script>
<script type="module" src="frontend/dist/frontend-provided.js" data-src="assets/frontend-provided.js"></script>
""".strip()  # TODO: ADJUST SRC -> will be in assets!


def _patch_html(html, server_start):
    """
    Patches the given HTML by injecting the payload generated by `_inject`.
    This function tries to be consistent with the existing HTML, thus it first tries to place the injection inside
    the page's body, then its root-element and if everything fails, it just appends the injection.

    :param server_start: the ISO-Timestamp when the server started, passed to `_inject`
    """
    # prepare the inection
    from stock import STOCK
    injection = _inject(server_start, stock=tuple(STOCK))

    # inject in the "most semantic" manner
    if '</body>' in html:
        return html.replace('</body>', injection + '</body>')
    elif '</html>' in html:
        return html.replace('</html>', injection + '</html>')
    else:
        return html + injection


@static.route('/')
@static.route('/<path:filename>')
def serve(filename='index.html'):
    """
    Serves static files and passes all html files through `_patch_html` first.
    This handler protects agains escaping the servers `config['static_folder']`.

    :param filename: The filename, received through the URL
    """

    # extract the config values
    static_folder = current_app.config['static_folder']
    server_start = current_app.config['server_start']

    # build the requested path
    requested_path = os.path.join(static_folder, filename)

    # validate the requested path
    if not os.path.exists(requested_path):
        abort(404)

    if not os.path.isfile(requested_path):
        abort(400)

    if not os.path.commonpath([requested_path, static_folder]) == static_folder:
        abort(403)

    # patch HTML files first
    if requested_path.endswith('.html'):

        # read the entire file
        with open(requested_path, mode='r', encoding='utf8') as f:
            html_content = f.read()

        patched_html = _patch_html(html_content, server_start)

        # return the response manually
        return Response(patched_html, content_type='text/html')

    # otherwise just send the file
    return send_file(requested_path)
